//
//  main.cpp
//  K-Means
//
//  Created by Sathvik Birudavolu on 12/12/15.
//  Copyright Â© 2015 Sathvik Birudavolu. All rights reserved.
//

#include <iostream>
#include <random>
#include <cmath>
#include <iomanip>
#include <opencv2/opencv.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/core/core.hpp>

using namespace cv;
using namespace std;


class Points{
    
public:
    int dims = 0;
private: double *points;
    int cluster_num = INT16_MAX;
    
public:
    
    /* Point (int d){
     points = new double[d];
     *points = NULL;
     }*/
    double* getPoints(){
        return points;
    }
    
    double getPoint(int index){
        return points[index];
    }
    
    void setPoints(double *points){
        this->points = points;
    }
    
    void setPoint (int index, double point) {
        this->points[index] = point;
    }
    
    void setDim(int dims){
        this->dims = dims;
    }
    
    int getClusterNum(){
        return cluster_num;
    }
    
    void setClusterNum(int num){
        cluster_num = num;
    }
    /*Point (const Point &p){
     points = new double[this->dims];
     *points = *p.getPoints();
     }*/
    
};


class NDimKMeans {
    
private:
    int dims = 0;
    int K = 0;
    int numPoints = 0;
    Points *points;
    
public:
    NDimKMeans(int dims, int K, int numPoints, Points *points) {
        this->dims = dims;
        this->K = K;
        this->numPoints = numPoints;
        this->points = points;
    }
    
public:
    double** getClusters() {
        
        int count = 0;
        Points *mean_p = new Points[K];
        
        bool isFinished = false;
        
        
        double **means = new double *[K];
        for (int i = 0; i < K; i++) { means[i] = new double[dims]; }
        
        double **means_prev = new double *[K];
        for (int i = 0; i < K; i++) means_prev[i] = new double[dims];
        
        mean_p[0].setPoints(new double[2]{100,110});
        mean_p[0].setClusterNum(0);
        mean_p[1].setPoints(new double[2]{250,200});
        mean_p[1].setClusterNum(1);
        mean_p[2].setPoints(new double[2]{300,300});
        mean_p[2].setClusterNum(2);
        
    loop:
        while (!isFinished) {
            
            
            for (int i = 0; i < numPoints; i++) {   //Go through All points
                
                
                double *test_p = points[i].getPoints();
                
                //cout <<i << " "<< test_p[0] << " " << test_p[1] << endl;
                int min_index = 0;
                double min = INT16_MAX;
                
                for (int j = 0; j < K; j++) {
                    
                    double dist = 0;
                    for (int l = 0; l < dims; l++) { dist += pow(test_p[l] - mean_p[j].getPoint(l), 2); }
                    dist = sqrt(dist);
                    //cout << numPoints << " "<< i << " " << j << " " << dist << endl;
                    
                    //cout << dist << " " << endl;
                    if (dist < min) {
                        min = dist;
                        //cout << min << " ";
                        min_index = j;
                    }
                }
                cout << endl;
                points[i].setClusterNum(min_index);
                cout << test_p[0] <<"             " << test_p[1] << "    "<< points[i].getClusterNum() << endl;
            }
            
            
            
            if(count%2 == 0){
                
                for(int i=0; i<K; i++)
                    for(int j=0; j<dims; j++)
                        means_prev[i][j] = 0;
                
                double *d = new double[K];
                
                for (int l = 0; l < numPoints; l++) {
                    for (int j = 0; j < dims; j++){
                        means_prev[points[l].getClusterNum()][j] += points[l].getPoint(j);
                        
                        if (j == 0)d[points[l].getClusterNum()]++;
                    }
                }
                
                
                for (int l = 0; l < K; l++)
                    for (int k = 0; k < dims; k++) {
                        means_prev[l][k] /= d[l];
                        mean_p[l].setPoint(k, means_prev[l][k]);
                        
                    }
            
                
            }else{
                
                for(int i=0; i<K; i++)
                    for(int j=0; j<dims; j++)
                        means[i][j] = 0;
                
                
                double *d = new double[K];
                for (int j = 0; j < dims; j++) {
                    for (int l = 0; l < numPoints; l++) {
                        means[points[l].getClusterNum()][j] += points[l].getPoint(j);
                        if (j == 0) d[points[l].getClusterNum()]++;
                    }
                }
                
                for (int l = 0; l < K; l++)
                    for (int k = 0; k < dims; k++) {
                        means[l][k] /= d[l];
                        mean_p[l].setPoint(k, means[l][k]);
                    }
                
                int c = 0;
                for (int i = 0; i < K; i++)
                    for (int k = 0; k < dims; k++) {
                        if (means[i][k] == means_prev[i][k]) { c++; }
                    }
                if (c == K * dims) break ;
            }
            
            count++;
        }
        
        
        return means;
        
    }
};


void cvDisplayVectors(double** means, Points* points, int K ,int numPoints);

int main() {
    
    int dims = 2;
    int K = 3;
    int numPoints = 150;
    
    Points* points = new Points [numPoints];
    for(int i=0; i<numPoints; i++)points[i].setDim(dims);
    
    // I got these points online i put in only 5 because it would be easier to track where my algorithm was going wrrong
    // and the correct means for the points was A(0.7,1) and B(2.5 , 4.5) and i got the same answers with more precision
   
  //  points[0].setPoints(new double[2]{100,100});
  //  points[1].setPoints(new double[2]{200,200});
  //  points[2].setPoints(new double[2]{400,400});
    //points[3].setPoints(new double[2]{2,4});
    //points[4].setPoints(new double[2]{3,5});
    
    
    default_random_engine gen;
    
    for(int j=0 ; j< K; j++){
        normal_distribution<> n_dist(100+100*j,20);
        for(int i=0 ;i<numPoints/K; i++){
            cout <<  "                      " << n_dist(gen) <<endl;
            points[j*(numPoints/K)+i].setPoints(new double[2]{abs(n_dist(gen)),abs(n_dist(gen))});
            
        }
    }
    
    
    NDimKMeans m(dims, K, numPoints, points); // Each point in test_p has a cluster

    double** means = m.getClusters();

    for(int i=0; i < K; i++){
        cout << means[i][0] << " "<< means[i][1] << " " <<endl;
    }
    
    cvDisplayVectors(means,points,K ,numPoints);

    
    return 0;
}

void cvDisplayVectors(double** means, Points* points, int K, int numPoints){
    
    namedWindow("A", WINDOW_FULLSCREEN);
    Mat img = imread("/Users/BSathvik/Downloads/White_Canvas.jpg", CV_LOAD_IMAGE_COLOR);
    
    Scalar mean_colors(0,0,0);
    
    Scalar *colors_clusters = new Scalar[K];
    
    for(int i=0; i<K; i++)
        colors_clusters[i] = *new Scalar(rand()%255,rand()%255,rand()%255);
    
    
    
    for(int i=0 ; i<numPoints; i++){
        circle(img, *new Point(points[i].getPoint(0),points[i].getPoint(1)), 3, colors_clusters[points[i].getClusterNum()] , 3);
    }
    
    for(int i=0; i<K; i++){
        circle(img, *new Point(means[i][0],means[i][1]), 4 , mean_colors,4);
    }
    
    imshow("A", img);
    
    cvWaitKey(0);
    
}

